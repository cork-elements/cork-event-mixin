

<script>
  const EventMixin = subclass =>

class EventElement extends subclass {
  static get properties() {
    return {
      active : {
        type : Boolean,
        value : false,
        observer : '_onActive'
      }
    }
  }

  get bind() {
    return {};
  }

  constructor() {
    super();
    // have we initialized the handlers?
    this._eb_handlersSet = false;
    // do we want to detach listeners when element is detached
    // (prevent memory leaks)
    this._eb_unregisterOnDetach = true;
  }

  ready() {
    super.ready();
    this._eb_init();
  }

  connectedCallback() {
    super.connectedCallback();
    this._eb_init();
  }
  
  _eb_init() {
    if( this._eb_handlersSet || !this.getEventBus() ) return;

    this._eb_handlersSet = true;
    
    for( var key in this.bind ) {
      if( !this[this.bind[key]] ) {
        console.warn(`${this.nodeName} could not bind event ${key} to ${this.bind[key]}`);
        continue;
      }
      this._eb_init_fn(key);
    }
  }

  _eb_init_fn(key) {
    this[this.bind[key]] = this[this.bind[key]].bind(this);
    this.getEventBus().on(key, function() {
      this[this.bind[key]].apply(this, arguments);
    }.bind(this));
  }
    
  disconnectedCallback() {
    super.disconnectedCallback();
    if( !this._eb_unregisterOnDetach || !this.getEventBus() ) return;
    this._eb_handlersSet = false;
    
    for( var key in this.bind ) {
      if( !this[this.bind[key]] ) continue;
      this.getEventBus().removeListener(key, this[this.bind[key]]);
    }
  }

  getEventBus() {
    if( this.EVENT_BUS && window[this.EVENT_BUS] ) {
      return window[this.EVENT_BUS];
    }
    return window.EventBus;
  }
  
  emit() {
    if( !EventBus._events[arguments[0]] ) {
      console.warn(`No event registered: ${arguments[0]}`);
    }

    var args = [arguments[0]];

    return new Promise((resolve, reject) => {
      args.push(resolve);
      args.push(reject);

      for( var i = 1; i < arguments.length; i++ ) {
        args.push(arguments[i]);
      }

      this.getEventBus().emit.apply(this.getEventBus(), args);
    });
  }
  
  // adding polymer 1.0 helper back in
  fire(event, payload = {}) {
    this.dispatchEvent(
      new CustomEvent(
        event, 
        {
          detail: payload,
          bubbles: true, 
          composed: true
        }
      )
    );
  }

  // adding polymer 1.0 helper back in
  debounce(name, callback, timeout) {
    name = `_${name}Debouncer`;
    this[name] = Polymer.Debouncer.debounce(
      this[name],
      Polymer.Async.timeOut.after(timeout),
      callback.bind(this)
    );
  }
  
  _onActive() {
    // implement me
  }
}
</script>
